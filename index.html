<!-- I need to put this here, dont ask why --><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bread Quest</title>
    <style>
        body {
            font-family: "Comic Sans MS", "Comic Sans", cursive;
            margin: 0;
            overflow: hidden;
            background-color: #f4e7da;
        }
        canvas {
            display: block;
            margin: 0 auto;
            background-color: #ffebb7;
            border: 2px solid #c9aa74;
        }
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="stats">
        <div>üçû Toppings: <span id="toppings-count">0</span></div>
        <div>üíõ Score: <span id="player-score">0</span></div>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <audio loop id="bg-music" src="placeholder_music_path"></audio>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const toppingsCounter = document.getElementById('toppings-count');
        const scoreCounter = document.getElementById('player-score');
        const bgMusic = document.getElementById('bg-music');

        // Game variables
        const gridSize = 40;
        let player = { x: 0, y: 0, score: 0, toppings: 0 };
        let enemies = [];
        let toppings = [];
        let keys = {};

        // Sample areas (Rye Ridge, Sourdough Summit, Baguette Bridge)
        const gameMap = [
            ['_', '_', 'üçû', '_', '_', 'ü•ñ'],
            ['_', 'ü•ñ', '_', 'üçû', 'ü•ñ', '_'],
            ['_', '_', 'ü•ñ', '_', '_', 'üçû'],
            ['üçû', '_', '_', 'ü•ñ', '_', '_'],
            ['_', 'ü•ñ', '_', '_', 'üçû', '_']
        ];

        // Initialize enemies
        function initEnemies() {
            enemies.push({ type: 'fork', x: 80, y: 120 });
            enemies.push({ type: 'knife', x: 200, y: 300 });
            enemies.push({ type: 'toaster', x: 400, y: 400 });
        }

        // Initialize toppings
        function initToppings() {
            gameMap.forEach((row, y) => {
                row.forEach((cell, x) => {
                    if (cell === 'ü•ñ') {
                        toppings.push({ x: x * gridSize, y: y * gridSize });
                    }
                });
            });
        }

        function drawMap() {
            gameMap.forEach((row, y) => {
                row.forEach((cell, x) => {
                    if (cell === '_') {
                        ctx.fillStyle = '#d4c3aa'; // path color
                    } else {
                        ctx.fillStyle = '#f5e0c3'; // loaf color
                    }
                    ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                });
            });
        }

        function drawPlayer() {
            ctx.fillStyle = '#c29b6d'; // slice of bread color
            ctx.fillRect(player.x, player.y, gridSize, gridSize);
            ctx.fillText('üçû', player.x + 5, player.y + 30); // bread emoji
        }

        function drawEnemiesAndToppings() {
            ctx.font = '24px Arial';
            
            enemies.forEach(enemy => {
                if (enemy.type === 'fork') {
                    ctx.fillText('üç¥', enemy.x + 5, enemy.y + 30);
                } else if (enemy.type === 'knife') {
                    ctx.fillText('üî™', enemy.x + 5, enemy.y + 30);
                } else if (enemy.type === 'toaster') {
                    ctx.fillText('üîå', enemy.x + 5, enemy.y + 30);
                }
            });

            toppings.forEach(topping => {
                ctx.fillText('ü•ñ', topping.x + 5, topping.y + 30);
            });
        }

        function update() {
            // Player Movement
            if (keys['ArrowUp'] && player.y > 0) player.y -= gridSize;
            if (keys['ArrowDown'] && player.y < canvas.height - gridSize) player.y += gridSize;
            if (keys['ArrowLeft'] && player.x > 0) player.x -= gridSize;
            if (keys['ArrowRight'] && player.x < canvas.width - gridSize) player.x += gridSize;

            // Collecting toppings
            toppings = toppings.filter(topping => {
                if (player.x === topping.x && player.y === topping.y) {
                    player.toppings++;
                    player.score += 10;
                    toppingsCounter.textContent = player.toppings;
                    scoreCounter.textContent = player.score;
                    return false;
                }
                return true;
            });

            // Enemy interactions can be expanded based on specific attributes
            enemies.forEach(enemy => {
                if (player.x === enemy.x && player.y === enemy.y) {
                    player.score -= 5;
                    scoreCounter.textContent = player.score;
                }
            });
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawMap();
            drawPlayer();
            drawEnemiesAndToppings();
            update();
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            initEnemies();
            initToppings();
            bgMusic.volume = 0.2;
            bgMusic.play();
            gameLoop();
        }

        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        startGame();

    </script>
</body>
</html>