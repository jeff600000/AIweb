<!-- I need to put this here, dont ask why --><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bread Quest</title>
    <style>
        body {
            background-color: #f8efe4;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Arial', sans-serif;
        }

        #gameCanvas {
            border: 2px solid #b5651d;
            background-color: #ffeeda;
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const BREAD_SIZE = 30;
        const TOAST_TIME = 60;
        let bread = { x: 50, y: 50, size: BREAD_SIZE, vx: 5, vy: 5 };
        let obstacles = [];
        let toppings = [];
        let score = 0;
        let timeLeft = TOAST_TIME;
        let gameInterval;
        let timerInterval;

        function drawBread() {
            const breadImg = new Image();
            breadImg.src = 'path_to_bread_image';
            breadImg.onload = () => {
                ctx.drawImage(breadImg, bread.x, bread.y, bread.size, bread.size);
            };
        }

        function updateGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBread();
            updateObstacles();
            updateToppings();
            checkCollisions();
            displayScore();
            displayTimer();
        }

        function drawObstacles() {
            ctx.fillStyle = 'black';
            obstacles.forEach(obstacle => {
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.size, obstacle.size);
            });
        }

        function updateObstacles() {
            obstacles.forEach(obstacle => {
                obstacle.y += 2; 
                if (obstacle.y > canvas.height) {
                    obstacle.y = 0;
                    obstacle.x = Math.random() * canvas.width;
                }
            });
        }

        function drawToppings() {
            toppings.forEach(topping => {
                ctx.fillStyle = topping.color;
                ctx.fillRect(topping.x, topping.y, topping.size, topping.size);
            });
        }

        function updateToppings() {
            toppings.forEach(topping => {
                topping.y += 1;
                if (topping.y > canvas.height) {
                    topping.y = -10;
                    topping.x = Math.random() * canvas.width;
                }
            });
        }

        function checkCollisions() {
            obstacles.forEach(obstacle => {
                if (
                    bread.x < obstacle.x + obstacle.size &&
                    bread.x + bread.size > obstacle.x &&
                    bread.y < obstacle.y + obstacle.size &&
                    bread.y + bread.size > obstacle.y
                ) {
                    endGame();
                }
            });

            toppings = toppings.filter(topping => {
                if (
                    bread.x < topping.x + topping.size &&
                    bread.x + bread.size > topping.x &&
                    bread.y < topping.y + topping.size &&
                    bread.y + bread.size > topping.y
                ) {
                    score += topping.points;
                    return false;
                }
                return true;
            });
        }

        function displayScore() {
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.fillText(`Score: ${score}`, 10, 20);
        }

        function displayTimer() {
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.fillText(`Time Left: ${timeLeft}`, canvas.width - 150, 20);
        }

        function moveBread(event) {
            switch (event.key) {
                case 'ArrowUp':
                    if (bread.y > 0) bread.y -= bread.vy;
                    break;
                case 'ArrowDown':
                    if (bread.y + bread.size < canvas.height) bread.y += bread.vy;
                    break;
                case 'ArrowLeft':
                    if (bread.x > 0) bread.x -= bread.vx;
                    break;
                case 'ArrowRight':
                    if (bread.x + bread.size < canvas.width) bread.x += bread.vx;
                    break;
            }
        }

        function initGame() {
            for (let i = 0; i < 5; i++) {
                obstacles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: 20
                });
            }

            toppings.push({ x: 200, y: 0, size: 10, points: 10, color: 'yellow' });
            toppings.push({ x: 300, y: -20, size: 10, points: 20, color: 'red' });
            toppings.push({ x: 400, y: -50, size: 10, points: 30, color: 'orange' });

            gameInterval = setInterval(updateGame, 1000 / 60);
            timerInterval = setInterval(updateTimer, 1000);
            document.addEventListener('keydown', moveBread);
        }

        function updateTimer() {
            if (timeLeft > 0) {
                timeLeft--;
            } else {
                endGame();
            }
        }

        function endGame() {
            clearInterval(gameInterval);
            clearInterval(timerInterval);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillText(`Game Over! Final Score: ${score}`, 100, canvas.height / 2);
            ctx.fillText('Refresh to Restart', 120, canvas.height / 2 + 30);
        }

        initGame();
    </script>
</body>
</html>